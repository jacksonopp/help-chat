package main

import (
	"context"
	"fmt"
	"log"
	"net/http"
	"os"
	"os/signal"
	"syscall"
	"time"

	_ "dev.azure.com/clearpointhealth/ClearQuoteV3/_git/helpchat/docs" // This is generated by swag
	"github.com/labstack/echo/v4"
	"github.com/labstack/echo/v4/middleware"
	echoSwagger "github.com/swaggo/echo-swagger"

	"dev.azure.com/clearpointhealth/ClearQuoteV3/_git/helpchat/internal/config"
	"dev.azure.com/clearpointhealth/ClearQuoteV3/_git/helpchat/internal/handlers"
	authMiddleware "dev.azure.com/clearpointhealth/ClearQuoteV3/_git/helpchat/internal/middleware"
	"dev.azure.com/clearpointhealth/ClearQuoteV3/_git/helpchat/internal/repository"
	"dev.azure.com/clearpointhealth/ClearQuoteV3/_git/helpchat/internal/services"
	"dev.azure.com/clearpointhealth/ClearQuoteV3/_git/helpchat/pkg/database"
)

// @title HelpChat API
// @version 1.0
// @description A RESTful API for the HelpChat application
// @termsOfService http://swagger.io/terms/

// @contact.name API Support
// @contact.url http://www.swagger.io/support
// @contact.email support@swagger.io

// @license.name Apache 2.0
// @license.url http://www.apache.org/licenses/LICENSE-2.0.html

// @host localhost:8080
// @BasePath /

// @securityDefinitions.apikey ApiKeyAuth
// @in header
// @name Authorization
// @description Type "Bearer" followed by a space and JWT token.

func main() {
	// Load configuration
	cfg := config.Load()

	// Initialize database
	db, err := database.NewDatabase(cfg)
	if err != nil {
		log.Fatal("Failed to connect to database:", err)
	}
	defer db.Close()

	// Run database migrations
	if err := database.RunMigrations(db); err != nil {
		log.Fatal("Failed to run migrations:", err)
	}

	// Create database indexes
	if err := database.CreateIndexes(db); err != nil {
		log.Fatal("Failed to create indexes:", err)
	}

	// Seed database with initial data
	if err := database.SeedDatabase(db); err != nil {
		log.Fatal("Failed to seed database:", err)
	}

	// Initialize Echo instance
	e := echo.New()

	// Configure Echo
	e.Logger.SetLevel(1) // INFO level
	e.HideBanner = true
	e.HidePort = true

	// Setup middleware
	setupMiddleware(e)

	// Initialize repositories
	userRepo := repository.NewUserRepository(db)
	ticketRepo := repository.NewTicketRepository(db)
	categoryRepo := repository.NewCategoryRepository(db)
	commentRepo := repository.NewCommentRepository(db)
	attachmentRepo := repository.NewAttachmentRepository(db)

	// Initialize services
	authService := services.NewAuthService(userRepo, cfg)
	ticketService := services.NewTicketService(ticketRepo, categoryRepo, commentRepo, attachmentRepo, userRepo)

	// Initialize middleware
	authMiddlewareInstance := authMiddleware.NewAuthMiddleware(authService)

	// Initialize handlers
	pingHandler := handlers.NewPingHandler(db)
	authHandler := handlers.NewAuthHandler(authService)
	ticketHandler := handlers.NewTicketHandler(ticketService)

	// Setup routes
	setupRoutes(e, pingHandler, authHandler, ticketHandler, authMiddlewareInstance)

	// Start server
	go func() {
		addr := fmt.Sprintf("%s:%s", cfg.Server.Host, cfg.Server.Port)
		log.Printf("Server starting on %s", addr)

		if err := e.Start(addr); err != nil && err != http.ErrServerClosed {
			log.Fatal("Failed to start server:", err)
		}
	}()

	// Wait for interrupt signal to gracefully shutdown the server
	quit := make(chan os.Signal, 1)
	signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)
	<-quit

	log.Println("Shutting down server...")
	ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
	defer cancel()

	if err := e.Shutdown(ctx); err != nil {
		log.Fatal("Server forced to shutdown:", err)
	}

	log.Println("Server exited")
}

func setupMiddleware(e *echo.Echo) {
	// Request logging middleware
	e.Use(middleware.LoggerWithConfig(middleware.LoggerConfig{
		Format: "method=${method}, uri=${uri}, status=${status}, latency=${latency}, latency_human=${latency_human}\n",
	}))

	// Recover middleware
	e.Use(middleware.Recover())

	// Request ID middleware
	e.Use(middleware.RequestID())

	// Validation middleware
	e.Use(authMiddleware.ValidationMiddleware())

	// Error handling middleware (must be last to catch all errors)
	e.Use(authMiddleware.ErrorHandlerMiddleware())
}

func setupRoutes(e *echo.Echo, pingHandler *handlers.PingHandler, authHandler *handlers.AuthHandler, ticketHandler *handlers.TicketHandler, authMiddlewareInstance *authMiddleware.AuthMiddleware) {
	// Swagger documentation
	e.GET("/swagger/*", echoSwagger.WrapHandler)

	// Register routes from handlers
	pingHandler.RegisterRoutes(e)
	authHandler.RegisterRoutes(e, authMiddlewareInstance)
	ticketHandler.RegisterRoutes(e, authMiddlewareInstance)
}
